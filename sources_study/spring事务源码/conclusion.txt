1.spring中的事务通过proxy的方法代理了目标方法,通过判断方法执行过程中是否发生异常,决定提交还是回退
2.spring事务的具体实现是需要使用EnableTranactionManager的注解,在这个注解中通过Import标签引入
TransactionManagementConfigurationSelector这个类,实现具体事务的Proxy代理
3.在TransactionManagementConfigurationSelector通过判断Advice的类型决定
使用Proxy还是使用Aspect代理方式,默认是使用Proxy方法
4.在TransactionManagementConfigurationSelector的selectImport方法中创建Proxy的过程中通过创建
AutoProxyRegister这个类,在sping-core加载BeanDefition的过程中创建了代理类
5.在方法执行的过程中通过TransactionInterceptor拦截器实现了具体的事务拦截
6.在TransactionInterceptor执行具体拦截的方法的过程中,首先会判断目标方法是否存在事务注解,如果存在则
判断使用ReactiveTrantionManagerment执行还是使用CallBackTranactionManagement执行,如果不存在则直接
调用目标方法
7.在使用事务管理执行事务的过程中,通过判断执行方法的过程中是否发生异常决定是提交还是回退,值得注意的是
即使发生异常也可能存在提交,具体是否提交由TransactionInfo中的transactionStatus决定
